// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: Fornecedor.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const atualizarFornecedor = `-- name: AtualizarFornecedor :execrows
UPDATE fornecedores
SET 
    razao_social       = COALESCE($1, razao_social),
    nome_fantasia      = COALESCE($2, nome_fantasia),
    cnpj               = COALESCE($3, cnpj),
    inscricao_estadual = COALESCE($4, inscricao_estadual)
WHERE 
    id = $5 
    AND tenant_id = $6 
    AND cancelado_em IS NULL
`

type AtualizarFornecedorParams struct {
	RazaoSocial       pgtype.Text
	NomeFantasia      pgtype.Text
	Cnpj              pgtype.Text
	InscricaoEstadual pgtype.Text
	ID                int32
	TenantID          int32
}

func (q *Queries) AtualizarFornecedor(ctx context.Context, arg AtualizarFornecedorParams) (int64, error) {
	result, err := q.db.Exec(ctx, atualizarFornecedor,
		arg.RazaoSocial,
		arg.NomeFantasia,
		arg.Cnpj,
		arg.InscricaoEstadual,
		arg.ID,
		arg.TenantID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const criarFornecedor = `-- name: CriarFornecedor :exec
INSERT INTO fornecedores (
    tenant_id, 
    razao_social, 
    nome_fantasia, 
    cnpj, 
    inscricao_estadual 
) VALUES (
    $1, $2, $3, $4, $5
)
`

type CriarFornecedorParams struct {
	TenantID          int32
	RazaoSocial       string
	NomeFantasia      string
	Cnpj              string
	InscricaoEstadual string
}

func (q *Queries) CriarFornecedor(ctx context.Context, arg CriarFornecedorParams) error {
	_, err := q.db.Exec(ctx, criarFornecedor,
		arg.TenantID,
		arg.RazaoSocial,
		arg.NomeFantasia,
		arg.Cnpj,
		arg.InscricaoEstadual,
	)
	return err
}

const deletarFornecedor = `-- name: DeletarFornecedor :execrows
UPDATE fornecedores
SET 
    ativo = FALSE,
    cancelado_em = NOW()
WHERE id = $1 AND tenant_id = $2 AND cancelado_em IS NULL
`

type DeletarFornecedorParams struct {
	ID       int32
	TenantID int32
}

func (q *Queries) DeletarFornecedor(ctx context.Context, arg DeletarFornecedorParams) (int64, error) {
	result, err := q.db.Exec(ctx, deletarFornecedor, arg.ID, arg.TenantID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getFornecedor = `-- name: GetFornecedor :one
SELECT id, tenant_id, razao_social, nome_fantasia, cnpj, inscricao_estadual, ativo, cancelado_em FROM fornecedores 
WHERE id = $1 AND tenant_id = $2 AND cancelado_em IS NULL
`

type GetFornecedorParams struct {
	ID       int32
	TenantID int32
}

func (q *Queries) GetFornecedor(ctx context.Context, arg GetFornecedorParams) (Fornecedore, error) {
	row := q.db.QueryRow(ctx, getFornecedor, arg.ID, arg.TenantID)
	var i Fornecedore
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.RazaoSocial,
		&i.NomeFantasia,
		&i.Cnpj,
		&i.InscricaoEstadual,
		&i.Ativo,
		&i.CanceladoEm,
	)
	return i, err
}

const listarFornecedores = `-- name: ListarFornecedores :many
SELECT 
    id, 
    razao_social, 
    nome_fantasia, 
    cnpj, 
    inscricao_estadual, 
    ativo,
    count(*) OVER() AS total_items -- Isso retorna o total para paginação sem precisar de duas queries
FROM fornecedores
WHERE 
    tenant_id = $1
        AND (
        ($2::boolean IS FALSE AND cancelada_em IS NULL) OR
        ($2::boolean IS TRUE AND cancelada_em IS NOT NULL)
    )
    AND cancelado_em IS NULL -- Soft Delete: Só traz os ativos
    AND ($3::text IS NULL OR nome_fantasia ILIKE '%' || $3 || '%' OR razao_social ILIKE '%' || $3 || '%')
    AND ($4::text IS NULL OR cnpj ILIKE '%' || $4 || '%')
ORDER BY id DESC
LIMIT $6 OFFSET $5
`

type ListarFornecedoresParams struct {
	TenantID   int32
	Canceladas bool
	Nome       pgtype.Text
	Cnpj       pgtype.Text
	Offset     int32
	Limit      int32
}

type ListarFornecedoresRow struct {
	ID                int32
	RazaoSocial       string
	NomeFantasia      string
	Cnpj              string
	InscricaoEstadual string
	Ativo             pgtype.Bool
	TotalItems        int64
}

func (q *Queries) ListarFornecedores(ctx context.Context, arg ListarFornecedoresParams) ([]ListarFornecedoresRow, error) {
	rows, err := q.db.Query(ctx, listarFornecedores,
		arg.TenantID,
		arg.Canceladas,
		arg.Nome,
		arg.Cnpj,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListarFornecedoresRow
	for rows.Next() {
		var i ListarFornecedoresRow
		if err := rows.Scan(
			&i.ID,
			&i.RazaoSocial,
			&i.NomeFantasia,
			&i.Cnpj,
			&i.InscricaoEstadual,
			&i.Ativo,
			&i.TotalItems,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
