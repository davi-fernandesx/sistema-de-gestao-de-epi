// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: EntradaEpi.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addEntradaEpi = `-- name: AddEntradaEpi :exec
INSERT INTO entrada_epi (
    IdEpi, IdTamanho, data_entrada, quantidade, quantidadeAtual, 
    data_fabricacao, data_validade, lote, fornecedor, valor_unitario,nota_fiscal_numero, nota_fiscal_serie
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
`

type AddEntradaEpiParams struct {
	Idepi            int32
	Idtamanho        int32
	DataEntrada      pgtype.Date
	Quantidade       int32
	Quantidadeatual  int32
	DataFabricacao   pgtype.Date
	DataValidade     pgtype.Date
	Lote             string
	Fornecedor       string
	ValorUnitario    pgtype.Numeric
	NotaFiscalNumero string
	NotaFiscalSerie  pgtype.Text
}

func (q *Queries) AddEntradaEpi(ctx context.Context, arg AddEntradaEpiParams) error {
	_, err := q.db.Exec(ctx, addEntradaEpi,
		arg.Idepi,
		arg.Idtamanho,
		arg.DataEntrada,
		arg.Quantidade,
		arg.Quantidadeatual,
		arg.DataFabricacao,
		arg.DataValidade,
		arg.Lote,
		arg.Fornecedor,
		arg.ValorUnitario,
		arg.NotaFiscalNumero,
		arg.NotaFiscalSerie,
	)
	return err
}

const cancelarEntrada = `-- name: CancelarEntrada :execrows
UPDATE entrada_epi
SET cancelada_em = NOW(),
    ativo = FALSE
WHERE id = $1 AND ativo = TRUE
`

func (q *Queries) CancelarEntrada(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, cancelarEntrada, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listarEntradas = `-- name: ListarEntradas :many
SELECT 
    ee.id, ee.IdEpi, e.nome as epi_nome, e.fabricante, e.CA, e.descricao as epi_descricao,
    ee.data_fabricacao, ee.data_validade, e.validade_CA,
    e.IdTipoProtecao, tp.nome as protecao_nome,
    ee.IdTamanho, t.tamanho as tamanho_nome, 
    ee.quantidade, ee.quantidadeAtual, ee.data_entrada,
    ee.lote, ee.fornecedor, ee.valor_unitario, ee.nota_fiscal_numero, ee.nota_fiscal_serie
FROM entrada_epi ee
INNER JOIN epi e ON ee.IdEpi = e.id
INNER JOIN tipo_protecao tp ON e.IdTipoProtecao = tp.id
INNER JOIN tamanho t ON ee.IdTamanho = t.id
WHERE 
    ($1::boolean IS FALSE AND ee.cancelada_em IS NULL) OR
    ($1::boolean IS TRUE AND ee.cancelada_em IS NOT NULL)
AND ($2::int IS NULL OR ee.IdEpi = $2)
AND ($3::int IS NULL OR ee.id = $3)
`

type ListarEntradasParams struct {
	Canceladas bool
	IDEpi      pgtype.Int4
	IDEntrada  pgtype.Int4
}

type ListarEntradasRow struct {
	ID               int32
	Idepi            int32
	EpiNome          string
	Fabricante       string
	Ca               string
	EpiDescricao     string
	DataFabricacao   pgtype.Date
	DataValidade     pgtype.Date
	ValidadeCa       pgtype.Date
	Idtipoprotecao   int32
	ProtecaoNome     string
	Idtamanho        int32
	TamanhoNome      string
	Quantidade       int32
	Quantidadeatual  int32
	DataEntrada      pgtype.Date
	Lote             string
	Fornecedor       string
	ValorUnitario    pgtype.Numeric
	NotaFiscalNumero string
	NotaFiscalSerie  pgtype.Text
}

func (q *Queries) ListarEntradas(ctx context.Context, arg ListarEntradasParams) ([]ListarEntradasRow, error) {
	rows, err := q.db.Query(ctx, listarEntradas, arg.Canceladas, arg.IDEpi, arg.IDEntrada)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListarEntradasRow
	for rows.Next() {
		var i ListarEntradasRow
		if err := rows.Scan(
			&i.ID,
			&i.Idepi,
			&i.EpiNome,
			&i.Fabricante,
			&i.Ca,
			&i.EpiDescricao,
			&i.DataFabricacao,
			&i.DataValidade,
			&i.ValidadeCa,
			&i.Idtipoprotecao,
			&i.ProtecaoNome,
			&i.Idtamanho,
			&i.TamanhoNome,
			&i.Quantidade,
			&i.Quantidadeatual,
			&i.DataEntrada,
			&i.Lote,
			&i.Fornecedor,
			&i.ValorUnitario,
			&i.NotaFiscalNumero,
			&i.NotaFiscalSerie,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
