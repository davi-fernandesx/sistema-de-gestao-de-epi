// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: EntradaEpi.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addEntradaEpi = `-- name: AddEntradaEpi :exec
INSERT INTO entrada_epi (
    tenant_id, -- Novo campo obrigatório
    IdEpi, IdTamanho, data_entrada, quantidade, quantidadeAtual, 
    data_fabricacao, data_validade, lote, Idfornecedor, valor_unitario, nota_fiscal_numero, nota_fiscal_serie, id_usuario_criacao
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
`

type AddEntradaEpiParams struct {
	TenantID         int32
	Idepi            int32
	Idtamanho        int32
	DataEntrada      pgtype.Date
	Quantidade       int32
	Quantidadeatual  int32
	DataFabricacao   pgtype.Date
	DataValidade     pgtype.Date
	Lote             string
	Idfornecedor     int32
	ValorUnitario    pgtype.Numeric
	NotaFiscalNumero string
	NotaFiscalSerie  pgtype.Text
	IDUsuarioCriacao pgtype.Int4
}

func (q *Queries) AddEntradaEpi(ctx context.Context, arg AddEntradaEpiParams) error {
	_, err := q.db.Exec(ctx, addEntradaEpi,
		arg.TenantID,
		arg.Idepi,
		arg.Idtamanho,
		arg.DataEntrada,
		arg.Quantidade,
		arg.Quantidadeatual,
		arg.DataFabricacao,
		arg.DataValidade,
		arg.Lote,
		arg.Idfornecedor,
		arg.ValorUnitario,
		arg.NotaFiscalNumero,
		arg.NotaFiscalSerie,
		arg.IDUsuarioCriacao,
	)
	return err
}

const cancelarEntrada = `-- name: CancelarEntrada :execrows
UPDATE entrada_epi 
SET 
    cancelada_em = NOW(), 
    ativo = FALSE,
    id_usuario_criacao_cancelamento = $2
WHERE id = $1 
  AND tenant_id = $3 -- SEGURANÇA: Só cancela se for do mesmo tenant
  AND cancelada_em IS NULL 
  AND quantidadeAtual = quantidade
`

type CancelarEntradaParams struct {
	ID                           int32
	IDUsuarioCriacaoCancelamento pgtype.Int4
	TenantID                     int32
}

func (q *Queries) CancelarEntrada(ctx context.Context, arg CancelarEntradaParams) (int64, error) {
	result, err := q.db.Exec(ctx, cancelarEntrada, arg.ID, arg.IDUsuarioCriacaoCancelamento, arg.TenantID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const contarEntradasFiltradas = `-- name: ContarEntradasFiltradas :one
SELECT COUNT(*) 
FROM entrada_epi ee
WHERE 
    ee.tenant_id = $1 -- SEGURANÇA: Filtro de Tenant
    AND (
        ($2::boolean IS FALSE AND ee.cancelada_em IS NULL) OR
        ($2::boolean IS TRUE AND ee.cancelada_em IS NOT NULL)
    )
    AND ($3::int IS NULL OR ee.IdEpi = $3)
    AND ($4::int IS NULL OR ee.id = $4)
    AND ($5::date IS NULL OR ee.data_entrada >= $5)
    AND ($6::date IS NULL OR ee.data_entrada <= $6)
    AND ($7::text IS NULL OR ee.nota_fiscal_numero ILIKE '%' || $7 || '%')
`

type ContarEntradasFiltradasParams struct {
	TenantID   int32
	Canceladas bool
	IDEpi      pgtype.Int4
	IDEntrada  pgtype.Int4
	DataInicio pgtype.Date
	DataFim    pgtype.Date
	NotaFiscal pgtype.Text
}

func (q *Queries) ContarEntradasFiltradas(ctx context.Context, arg ContarEntradasFiltradasParams) (int64, error) {
	row := q.db.QueryRow(ctx, contarEntradasFiltradas,
		arg.TenantID,
		arg.Canceladas,
		arg.IDEpi,
		arg.IDEntrada,
		arg.DataInicio,
		arg.DataFim,
		arg.NotaFiscal,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listarEntradas = `-- name: ListarEntradas :many
SELECT 
    ee.id, 
    ee.IdEpi, 
    e.nome as epi_nome, 
    e.fabricante, 
    e.CA, 
    e.descricao as epi_descricao,
    ee.data_fabricacao, 
    ee.data_validade, 
    e.validade_CA,
    e.IdTipoProtecao, 
    tp.nome as protecao_nome,
    ee.IdTamanho, 
    t.tamanho as tamanho_nome, 
    ee.quantidade, 
    ee.quantidadeAtual, 
    ee.data_entrada,
    ee.lote, 
    ee.Idfornecedor,
    f.razao_social,
    f.nome_fantasia,
    f.cnpj,
    f.inscricao_estadual,
    ee.valor_unitario, 
    ee.nota_fiscal_numero, 
    ee.nota_fiscal_serie, 
    
    -- Campos de Usuário Criação
    ee.id_usuario_criacao,
    u_criacao.nome as usuario_criacao_nome,
    
    -- Campos de Usuário Cancelamento
    ee.id_usuario_criacao_cancelamento,
    u_cancelamento.nome as usuario_cancelamento_nome,
    ee.cancelada_em -- É bom retornar a data também para saber quando foi

FROM entrada_epi ee
INNER JOIN epi e ON ee.IdEpi = e.id
INNER JOIN tipo_protecao tp ON e.IdTipoProtecao = tp.id
INNER JOIN tamanho t ON ee.IdTamanho = t.id
INNER JOIN fornecedores f on ee.IdFornecedor = f.id

LEFT JOIN usuarios u_criacao ON ee.id_usuario_criacao = u_criacao.id

LEFT JOIN usuarios u_cancelamento ON ee.id_usuario_criacao_cancelamento = u_cancelamento.id

WHERE 
    ee.tenant_id = $1
    AND (
        ($2::boolean IS FALSE AND ee.cancelada_em IS NULL) OR
        ($2::boolean IS TRUE AND ee.cancelada_em IS NOT NULL)
    )
    AND ($3::int IS NULL OR ee.IdEpi = $3)
    AND ($4::int IS NULL OR ee.id = $4)
    AND ($5::date IS NULL OR ee.data_entrada >= $5)
    AND ($6::date IS NULL OR ee.data_entrada <= $6)
    AND ($7::text IS NULL OR ee.nota_fiscal_numero ILIKE '%' || $7 || '%')
ORDER BY ee.data_entrada DESC
LIMIT $9 OFFSET $8
`

type ListarEntradasParams struct {
	TenantID   int32
	Canceladas bool
	IDEpi      pgtype.Int4
	IDEntrada  pgtype.Int4
	DataInicio pgtype.Date
	DataFim    pgtype.Date
	NotaFiscal pgtype.Text
	Offset     int32
	Limit      int32
}

type ListarEntradasRow struct {
	ID                           int32
	Idepi                        int32
	EpiNome                      string
	Fabricante                   string
	Ca                           string
	EpiDescricao                 string
	DataFabricacao               pgtype.Date
	DataValidade                 pgtype.Date
	ValidadeCa                   pgtype.Date
	Idtipoprotecao               int32
	ProtecaoNome                 string
	Idtamanho                    int32
	TamanhoNome                  string
	Quantidade                   int32
	Quantidadeatual              int32
	DataEntrada                  pgtype.Date
	Lote                         string
	Idfornecedor                 int32
	RazaoSocial                  string
	NomeFantasia                 string
	Cnpj                         string
	InscricaoEstadual            string
	ValorUnitario                pgtype.Numeric
	NotaFiscalNumero             string
	NotaFiscalSerie              pgtype.Text
	IDUsuarioCriacao             pgtype.Int4
	UsuarioCriacaoNome           pgtype.Text
	IDUsuarioCriacaoCancelamento pgtype.Int4
	UsuarioCancelamentoNome      pgtype.Text
	CanceladaEm                  pgtype.Timestamp
}

// JOIN 1: Quem criou a entrada
// JOIN 2: Quem cancelou a entrada (só vai retornar dados se tiver sido cancelada)
func (q *Queries) ListarEntradas(ctx context.Context, arg ListarEntradasParams) ([]ListarEntradasRow, error) {
	rows, err := q.db.Query(ctx, listarEntradas,
		arg.TenantID,
		arg.Canceladas,
		arg.IDEpi,
		arg.IDEntrada,
		arg.DataInicio,
		arg.DataFim,
		arg.NotaFiscal,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListarEntradasRow
	for rows.Next() {
		var i ListarEntradasRow
		if err := rows.Scan(
			&i.ID,
			&i.Idepi,
			&i.EpiNome,
			&i.Fabricante,
			&i.Ca,
			&i.EpiDescricao,
			&i.DataFabricacao,
			&i.DataValidade,
			&i.ValidadeCa,
			&i.Idtipoprotecao,
			&i.ProtecaoNome,
			&i.Idtamanho,
			&i.TamanhoNome,
			&i.Quantidade,
			&i.Quantidadeatual,
			&i.DataEntrada,
			&i.Lote,
			&i.Idfornecedor,
			&i.RazaoSocial,
			&i.NomeFantasia,
			&i.Cnpj,
			&i.InscricaoEstadual,
			&i.ValorUnitario,
			&i.NotaFiscalNumero,
			&i.NotaFiscalSerie,
			&i.IDUsuarioCriacao,
			&i.UsuarioCriacaoNome,
			&i.IDUsuarioCriacaoCancelamento,
			&i.UsuarioCancelamentoNome,
			&i.CanceladaEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
