// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: EntradaEpi.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addEntradaEpi = `-- name: AddEntradaEpi :exec
INSERT INTO entrada_epi (
    IdEpi, IdTamanho, data_entrada, quantidade, quantidadeAtual, 
    data_fabricacao, data_validade, lote, fornecedor, valor_unitario,nota_fiscal_numero, nota_fiscal_serie
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
`

type AddEntradaEpiParams struct {
	Idepi            int32
	Idtamanho        int32
	DataEntrada      pgtype.Date
	Quantidade       int32
	Quantidadeatual  int32
	DataFabricacao   pgtype.Date
	DataValidade     pgtype.Date
	Lote             string
	Fornecedor       string
	ValorUnitario    pgtype.Numeric
	NotaFiscalNumero string
	NotaFiscalSerie  pgtype.Text
}

func (q *Queries) AddEntradaEpi(ctx context.Context, arg AddEntradaEpiParams) error {
	_, err := q.db.Exec(ctx, addEntradaEpi,
		arg.Idepi,
		arg.Idtamanho,
		arg.DataEntrada,
		arg.Quantidade,
		arg.Quantidadeatual,
		arg.DataFabricacao,
		arg.DataValidade,
		arg.Lote,
		arg.Fornecedor,
		arg.ValorUnitario,
		arg.NotaFiscalNumero,
		arg.NotaFiscalSerie,
	)
	return err
}

const cancelarEntrada = `-- name: CancelarEntrada :execrows
UPDATE entrada_epi 
SET 
    cancelada_em = NOW(), 
    ativo = FALSE 
WHERE id = $1 
  AND cancelada_em IS NULL 
  AND quantidadeAtual = quantidade
`

func (q *Queries) CancelarEntrada(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, cancelarEntrada, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const contarEntradas = `-- name: ContarEntradas :one

SELECT COUNT(*) 
FROM entrada_epi ee
WHERE 
    (
        ($1::boolean IS FALSE AND ee.cancelada_em IS NULL) OR
        ($1::boolean IS TRUE AND ee.cancelada_em IS NOT NULL)
    )
    AND ($2::int IS NULL OR ee.IdEpi = $2)
    AND ($3::int IS NULL OR ee.id = $3)
    AND ($4::date IS NULL OR ee.data_entrada >= $4)
    AND ($5::date IS NULL OR ee.data_entrada <= $5)
    AND ($6::text IS NULL OR ee.nota_fiscal_numero ILIKE '%' || $6 || '%')
`

type ContarEntradasParams struct {
	Canceladas bool
	IDEpi      pgtype.Int4
	IDEntrada  pgtype.Int4
	DataInicio pgtype.Date
	DataFim    pgtype.Date
	NotaFiscal pgtype.Text
}

// Garante que nada foi usado
func (q *Queries) ContarEntradas(ctx context.Context, arg ContarEntradasParams) (int64, error) {
	row := q.db.QueryRow(ctx, contarEntradas,
		arg.Canceladas,
		arg.IDEpi,
		arg.IDEntrada,
		arg.DataInicio,
		arg.DataFim,
		arg.NotaFiscal,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listarEntradas = `-- name: ListarEntradas :many
SELECT 
    ee.id, ee.IdEpi, e.nome as epi_nome, e.fabricante, e.CA, e.descricao as epi_descricao,
    ee.data_fabricacao, ee.data_validade, e.validade_CA,
    e.IdTipoProtecao, tp.nome as protecao_nome,
    ee.IdTamanho, t.tamanho as tamanho_nome, 
    ee.quantidade, ee.quantidadeAtual, ee.data_entrada,
    ee.lote, ee.fornecedor, ee.valor_unitario, ee.nota_fiscal_numero, ee.nota_fiscal_serie
FROM entrada_epi ee
INNER JOIN epi e ON ee.IdEpi = e.id
INNER JOIN tipo_protecao tp ON e.IdTipoProtecao = tp.id
INNER JOIN tamanho t ON ee.IdTamanho = t.id
WHERE 
    (
        ($3::boolean IS FALSE AND ee.cancelada_em IS NULL) OR
        ($3::boolean IS TRUE AND ee.cancelada_em IS NOT NULL)
    )
    AND ($4::int IS NULL OR ee.IdEpi = $4)
    AND ($5::int IS NULL OR ee.id = $5)
    AND ($6::date IS NULL OR ee.data_entrada >= $6)
    AND ($7::date IS NULL OR ee.data_entrada <= $7)
    AND ($8::text IS NULL OR ee.nota_fiscal_numero ILIKE '%' || $8 || '%') -- Busca por NF
ORDER BY ee.data_entrada DESC
LIMIT $1 OFFSET $2
`

type ListarEntradasParams struct {
	Limit      int32
	Offset     int32
	Canceladas bool
	IDEpi      pgtype.Int4
	IDEntrada  pgtype.Int4
	DataInicio pgtype.Date
	DataFim    pgtype.Date
	NotaFiscal pgtype.Text
}

type ListarEntradasRow struct {
	ID               int32
	Idepi            int32
	EpiNome          string
	Fabricante       string
	Ca               string
	EpiDescricao     string
	DataFabricacao   pgtype.Date
	DataValidade     pgtype.Date
	ValidadeCa       pgtype.Date
	Idtipoprotecao   int32
	ProtecaoNome     string
	Idtamanho        int32
	TamanhoNome      string
	Quantidade       int32
	Quantidadeatual  int32
	DataEntrada      pgtype.Date
	Lote             string
	Fornecedor       string
	ValorUnitario    pgtype.Numeric
	NotaFiscalNumero string
	NotaFiscalSerie  pgtype.Text
}

func (q *Queries) ListarEntradas(ctx context.Context, arg ListarEntradasParams) ([]ListarEntradasRow, error) {
	rows, err := q.db.Query(ctx, listarEntradas,
		arg.Limit,
		arg.Offset,
		arg.Canceladas,
		arg.IDEpi,
		arg.IDEntrada,
		arg.DataInicio,
		arg.DataFim,
		arg.NotaFiscal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListarEntradasRow
	for rows.Next() {
		var i ListarEntradasRow
		if err := rows.Scan(
			&i.ID,
			&i.Idepi,
			&i.EpiNome,
			&i.Fabricante,
			&i.Ca,
			&i.EpiDescricao,
			&i.DataFabricacao,
			&i.DataValidade,
			&i.ValidadeCa,
			&i.Idtipoprotecao,
			&i.ProtecaoNome,
			&i.Idtamanho,
			&i.TamanhoNome,
			&i.Quantidade,
			&i.Quantidadeatual,
			&i.DataEntrada,
			&i.Lote,
			&i.Fornecedor,
			&i.ValorUnitario,
			&i.NotaFiscalNumero,
			&i.NotaFiscalSerie,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
