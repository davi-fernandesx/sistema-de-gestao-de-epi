// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: EntregaEpi.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addEntregaEpi = `-- name: AddEntregaEpi :one
INSERT INTO entrega_epi (IdFuncionario, data_entrega, assinatura)
VALUES ($1, $2, $3)
RETURNING id
`

type AddEntregaEpiParams struct {
	Idfuncionario int32
	DataEntrega   pgtype.Date
	Assinatura    string
}

func (q *Queries) AddEntregaEpi(ctx context.Context, arg AddEntregaEpiParams) (int32, error) {
	row := q.db.QueryRow(ctx, addEntregaEpi, arg.Idfuncionario, arg.DataEntrega, arg.Assinatura)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addItemEntregue = `-- name: AddItemEntregue :exec
INSERT INTO epis_entregues (IdEntrega, IdEpi, IdTamanho, quantidade, valor_unitario)
VALUES ($1, $2, $3, $4, $5)
`

type AddItemEntregueParams struct {
	Identrega     int32
	Idepi         int32
	Idtamanho     int32
	Quantidade    int32
	ValorUnitario pgtype.Numeric
}

func (q *Queries) AddItemEntregue(ctx context.Context, arg AddItemEntregueParams) error {
	_, err := q.db.Exec(ctx, addItemEntregue,
		arg.Identrega,
		arg.Idepi,
		arg.Idtamanho,
		arg.Quantidade,
		arg.ValorUnitario,
	)
	return err
}

const cancelarEntrega = `-- name: CancelarEntrega :execrows
UPDATE entrega_epi
SET cancelada_em = NOW(),
    ativo = FALSE
WHERE id = $1 AND cancelada_em IS NULL
`

func (q *Queries) CancelarEntrega(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, cancelarEntrega, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listarEntregas = `-- name: ListarEntregas :many
SELECT 
    ee.id as entrega_id, ee.data_entrega, ee.assinatura,
    f.id as func_id, f.nome as func_nome,
    d.id as dep_id, d.nome as dep_nome,
    ff.id as funcao_id, ff.nome as funcao_nome,
    e.id as epi_id, e.nome as epi_nome, e.fabricante, e.CA, e.descricao as epi_desc, e.validade_CA,
    tp.id as tp_id, tp.nome as tp_nome,
    t.id as tam_id, t.tamanho as tam_nome,
    i.quantidade, i.valor_unitario
FROM entrega_epi ee
INNER JOIN funcionario f ON ee.IdFuncionario = f.id
INNER JOIN departamento d ON f.IdDepartamento = d.id
INNER JOIN funcao ff ON f.IdFuncao = ff.id
INNER JOIN epis_entregues i ON i.IdEntrega = ee.id
INNER JOIN epi e ON i.IdEpi = e.id
INNER JOIN tipo_protecao tp ON e.IdTipoProtecao = tp.id
INNER JOIN tamanho t ON i.IdTamanho = t.id
WHERE 
    (($1::boolean IS FALSE AND ee.cancelada_em IS NULL) OR
     ($1::boolean IS TRUE AND ee.cancelada_em IS NOT NULL))
AND ($2::int IS NULL OR ee.id = $2)
AND ($3::int IS NULL OR ee.IdFuncionario = $3)
ORDER BY ee.data_entrega DESC
`

type ListarEntregasParams struct {
	Canceladas    bool
	IDEntrega     pgtype.Int4
	IDFuncionario pgtype.Int4
}

type ListarEntregasRow struct {
	EntregaID     int32
	DataEntrega   pgtype.Date
	Assinatura    string
	FuncID        int32
	FuncNome      string
	DepID         int32
	DepNome       string
	FuncaoID      int32
	FuncaoNome    string
	EpiID         int32
	EpiNome       string
	Fabricante    string
	Ca            string
	EpiDesc       string
	ValidadeCa    pgtype.Date
	TpID          int32
	TpNome        string
	TamID         int32
	TamNome       string
	Quantidade    int32
	ValorUnitario pgtype.Numeric
}

func (q *Queries) ListarEntregas(ctx context.Context, arg ListarEntregasParams) ([]ListarEntregasRow, error) {
	rows, err := q.db.Query(ctx, listarEntregas, arg.Canceladas, arg.IDEntrega, arg.IDFuncionario)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListarEntregasRow
	for rows.Next() {
		var i ListarEntregasRow
		if err := rows.Scan(
			&i.EntregaID,
			&i.DataEntrega,
			&i.Assinatura,
			&i.FuncID,
			&i.FuncNome,
			&i.DepID,
			&i.DepNome,
			&i.FuncaoID,
			&i.FuncaoNome,
			&i.EpiID,
			&i.EpiNome,
			&i.Fabricante,
			&i.Ca,
			&i.EpiDesc,
			&i.ValidadeCa,
			&i.TpID,
			&i.TpNome,
			&i.TamID,
			&i.TamNome,
			&i.Quantidade,
			&i.ValorUnitario,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
