// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: EntregaEpi.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addEntregaEpi = `-- name: AddEntregaEpi :one
INSERT INTO entrega_epi (
    tenant_id, -- Novo campo
    IdFuncionario, data_entrega, assinatura, IdTroca, token_validacao, id_usuario_entrega
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id
`

type AddEntregaEpiParams struct {
	TenantID         int32
	Idfuncionario    int32
	DataEntrega      pgtype.Date
	Assinatura       string
	Idtroca          pgtype.Int4
	TokenValidacao   pgtype.Text
	IDUsuarioEntrega pgtype.Int4
}

func (q *Queries) AddEntregaEpi(ctx context.Context, arg AddEntregaEpiParams) (int32, error) {
	row := q.db.QueryRow(ctx, addEntregaEpi,
		arg.TenantID,
		arg.Idfuncionario,
		arg.DataEntrega,
		arg.Assinatura,
		arg.Idtroca,
		arg.TokenValidacao,
		arg.IDUsuarioEntrega,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addItemEntregue = `-- name: AddItemEntregue :one
INSERT INTO epis_entregues (
    tenant_id, -- Novo campo (redundante mas necessário para segurança/performance)
    IdEntrega, IdEntrada, IdEpi, IdTamanho, quantidade
)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, IdEntrega
`

type AddItemEntregueParams struct {
	TenantID   int32
	Identrega  int32
	Identrada  int32
	Idepi      int32
	Idtamanho  int32
	Quantidade int32
}

type AddItemEntregueRow struct {
	ID        int32
	Identrega int32
}

func (q *Queries) AddItemEntregue(ctx context.Context, arg AddItemEntregueParams) (AddItemEntregueRow, error) {
	row := q.db.QueryRow(ctx, addItemEntregue,
		arg.TenantID,
		arg.Identrega,
		arg.Identrada,
		arg.Idepi,
		arg.Idtamanho,
		arg.Quantidade,
	)
	var i AddItemEntregueRow
	err := row.Scan(&i.ID, &i.Identrega)
	return i, err
}

const buscarTodosItensEntrega = `-- name: BuscarTodosItensEntrega :many
SELECT 
    i.IdEntrega as entrega_id, i.id as item_id, i.quantidade,
    e.id as epi_id, e.nome as epi_nome, e.fabricante, e.CA, e.descricao as epi_desc, e.validade_CA,
    tp.id as tp_id, tp.nome as tp_nome,
    t.id as tam_id, t.tamanho as tam_nome
FROM epis_entregues i
INNER JOIN epi e ON i.IdEpi = e.id
INNER JOIN tipo_protecao tp ON e.IdTipoProtecao = tp.id
INNER JOIN tamanho t ON i.IdTamanho = t.id
WHERE 
    i.tenant_id = $1 
    AND i.IdEntrega = $2 -- FALTOU ISSO
    AND i.ativo = TRUE
`

type BuscarTodosItensEntregaParams struct {
	TenantID  int32
	IDEntrega int32
}

type BuscarTodosItensEntregaRow struct {
	EntregaID  int32
	ItemID     int32
	Quantidade int32
	EpiID      int32
	EpiNome    string
	Fabricante string
	Ca         string
	EpiDesc    string
	ValidadeCa pgtype.Date
	TpID       int32
	TpNome     string
	TamID      int32
	TamNome    string
}

func (q *Queries) BuscarTodosItensEntrega(ctx context.Context, arg BuscarTodosItensEntregaParams) ([]BuscarTodosItensEntregaRow, error) {
	rows, err := q.db.Query(ctx, buscarTodosItensEntrega, arg.TenantID, arg.IDEntrega)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BuscarTodosItensEntregaRow
	for rows.Next() {
		var i BuscarTodosItensEntregaRow
		if err := rows.Scan(
			&i.EntregaID,
			&i.ItemID,
			&i.Quantidade,
			&i.EpiID,
			&i.EpiNome,
			&i.Fabricante,
			&i.Ca,
			&i.EpiDesc,
			&i.ValidadeCa,
			&i.TpID,
			&i.TpNome,
			&i.TamID,
			&i.TamNome,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const cancelaEntregaPorIdTroca = `-- name: CancelaEntregaPorIdTroca :one
UPDATE entrega_epi
SET cancelada_em = NOW(),
    ativo = FALSE,
    id_usuario_entrega_cancelamento = $2
WHERE IdTroca = $1 
  AND tenant_id = $3 -- SEGURANÇA
  AND cancelada_em IS NULL
RETURNING id
`

type CancelaEntregaPorIdTrocaParams struct {
	Idtroca                      pgtype.Int4
	IDUsuarioEntregaCancelamento pgtype.Int4
	TenantID                     int32
}

func (q *Queries) CancelaEntregaPorIdTroca(ctx context.Context, arg CancelaEntregaPorIdTrocaParams) (int32, error) {
	row := q.db.QueryRow(ctx, cancelaEntregaPorIdTroca, arg.Idtroca, arg.IDUsuarioEntregaCancelamento, arg.TenantID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const cancelaItemEntregue = `-- name: CancelaItemEntregue :many
UPDATE epis_entregues
SET ativo = FALSE, deletado_em = NOW()
WHERE IdEntrega = $1 
  AND tenant_id = $2 -- SEGURANÇA
RETURNING IdEntrada, quantidade
`

type CancelaItemEntregueParams struct {
	Identrega int32
	TenantID  int32
}

type CancelaItemEntregueRow struct {
	Identrada  int32
	Quantidade int32
}

func (q *Queries) CancelaItemEntregue(ctx context.Context, arg CancelaItemEntregueParams) ([]CancelaItemEntregueRow, error) {
	rows, err := q.db.Query(ctx, cancelaItemEntregue, arg.Identrega, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CancelaItemEntregueRow
	for rows.Next() {
		var i CancelaItemEntregueRow
		if err := rows.Scan(&i.Identrada, &i.Quantidade); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const cancelarEntrega = `-- name: CancelarEntrega :one
UPDATE entrega_epi
SET cancelada_em = NOW(),
    ativo = FALSE,
    id_usuario_entrega_cancelamento = $2
WHERE id = $1 
  AND tenant_id = $3 -- SEGURANÇA
  AND cancelada_em IS NULL
RETURNING id
`

type CancelarEntregaParams struct {
	ID                           int32
	IDUsuarioEntregaCancelamento pgtype.Int4
	TenantID                     int32
}

func (q *Queries) CancelarEntrega(ctx context.Context, arg CancelarEntregaParams) (int32, error) {
	row := q.db.QueryRow(ctx, cancelarEntrega, arg.ID, arg.IDUsuarioEntregaCancelamento, arg.TenantID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const listarEntregas = `-- name: ListarEntregas :many
SELECT 
    ee.id as entrega_id, ee.data_entrega, ee.assinatura, ee.token_validacao, ee.id_usuario_entrega,   
    f.id as func_id, f.nome as func_nome, f.matricula,
    d.id as dep_id, d.nome as dep_nome,
    ff.id as funcao_id, ff.nome as funcao_nome,
    e.id as epi_id, e.nome as epi_nome, e.fabricante, e.CA, e.descricao as epi_desc, e.validade_CA,
    tp.id as tp_id, tp.nome as tp_nome,
    t.id as tam_id, t.tamanho as tam_nome,
    i.quantidade,
    COUNT(*) OVER() as total_geral
FROM entrega_epi ee
INNER JOIN funcionario f ON ee.IdFuncionario = f.id
INNER JOIN departamento d ON f.IdDepartamento = d.id
INNER JOIN funcao ff ON f.IdFuncao = ff.id
INNER JOIN epis_entregues i ON i.IdEntrega = ee.id
INNER JOIN epi e ON i.IdEpi = e.id
INNER JOIN tipo_protecao tp ON e.IdTipoProtecao = tp.id
INNER JOIN tamanho t ON i.IdTamanho = t.id
WHERE 
    ee.tenant_id = $3 -- SEGURANÇA: Filtro Principal
    AND (
        ($4::boolean IS FALSE AND ee.cancelada_em IS NULL) OR
        ($4::boolean IS TRUE AND ee.cancelada_em IS NOT NULL)
    )
    AND ($5::int IS NULL OR ee.id = $5)
    AND ($6::int IS NULL OR ee.IdFuncionario = $6)
    AND ($7::date IS NULL OR ee.data_entrega >= $7)
    AND ($8::date IS NULL OR ee.data_entrega <= $8)
ORDER BY ee.data_entrega DESC
LIMIT $1 OFFSET $2
`

type ListarEntregasParams struct {
	Limit         int32
	Offset        int32
	TenantID      int32
	Canceladas    bool
	IDEntrega     pgtype.Int4
	IDFuncionario pgtype.Int4
	DataInicio    pgtype.Date
	DataFim       pgtype.Date
}

type ListarEntregasRow struct {
	EntregaID        int32
	DataEntrega      pgtype.Date
	Assinatura       string
	TokenValidacao   pgtype.Text
	IDUsuarioEntrega pgtype.Int4
	FuncID           int32
	FuncNome         string
	Matricula        string
	DepID            int32
	DepNome          string
	FuncaoID         int32
	FuncaoNome       string
	EpiID            int32
	EpiNome          string
	Fabricante       string
	Ca               string
	EpiDesc          string
	ValidadeCa       pgtype.Date
	TpID             int32
	TpNome           string
	TamID            int32
	TamNome          string
	Quantidade       int32
	TotalGeral       int64
}

func (q *Queries) ListarEntregas(ctx context.Context, arg ListarEntregasParams) ([]ListarEntregasRow, error) {
	rows, err := q.db.Query(ctx, listarEntregas,
		arg.Limit,
		arg.Offset,
		arg.TenantID,
		arg.Canceladas,
		arg.IDEntrega,
		arg.IDFuncionario,
		arg.DataInicio,
		arg.DataFim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListarEntregasRow
	for rows.Next() {
		var i ListarEntregasRow
		if err := rows.Scan(
			&i.EntregaID,
			&i.DataEntrega,
			&i.Assinatura,
			&i.TokenValidacao,
			&i.IDUsuarioEntrega,
			&i.FuncID,
			&i.FuncNome,
			&i.Matricula,
			&i.DepID,
			&i.DepNome,
			&i.FuncaoID,
			&i.FuncaoNome,
			&i.EpiID,
			&i.EpiNome,
			&i.Fabricante,
			&i.Ca,
			&i.EpiDesc,
			&i.ValidadeCa,
			&i.TpID,
			&i.TpNome,
			&i.TamID,
			&i.TamNome,
			&i.Quantidade,
			&i.TotalGeral,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listarItensEntregueCancelados = `-- name: ListarItensEntregueCancelados :many
SELECT quantidade, IdEntrada
FROM epis_entregues
WHERE IdEntrega = $1 
  AND tenant_id = $2 -- SEGURANÇA
  AND ativo = FALSE 
  AND deletado_em IS NOT NULL
`

type ListarItensEntregueCanceladosParams struct {
	Identrega int32
	TenantID  int32
}

type ListarItensEntregueCanceladosRow struct {
	Quantidade int32
	Identrada  int32
}

func (q *Queries) ListarItensEntregueCancelados(ctx context.Context, arg ListarItensEntregueCanceladosParams) ([]ListarItensEntregueCanceladosRow, error) {
	rows, err := q.db.Query(ctx, listarItensEntregueCancelados, arg.Identrega, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListarItensEntregueCanceladosRow
	for rows.Next() {
		var i ListarItensEntregueCanceladosRow
		if err := rows.Scan(&i.Quantidade, &i.Identrada); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
