// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: Devolucao.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addDevolucaoSimples = `-- name: AddDevolucaoSimples :exec
INSERT INTO devolucao (
    IdFuncionario, IdEpi, IdMotivo, data_devolucao, IdTamanho, 
    quantidadeAdevolver, assinatura_digital
) VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type AddDevolucaoSimplesParams struct {
	Idfuncionario       int32
	Idepi               int32
	Idmotivo            int32
	DataDevolucao       pgtype.Date
	Idtamanho           int32
	Quantidadeadevolver int32
	AssinaturaDigital   string
}

func (q *Queries) AddDevolucaoSimples(ctx context.Context, arg AddDevolucaoSimplesParams) error {
	_, err := q.db.Exec(ctx, addDevolucaoSimples,
		arg.Idfuncionario,
		arg.Idepi,
		arg.Idmotivo,
		arg.DataDevolucao,
		arg.Idtamanho,
		arg.Quantidadeadevolver,
		arg.AssinaturaDigital,
	)
	return err
}

const addEntregaVinculada = `-- name: AddEntregaVinculada :one
INSERT INTO entrega_epi (IdFuncionario, data_entrega, assinatura, IdTroca)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type AddEntregaVinculadaParams struct {
	Idfuncionario int32
	DataEntrega   pgtype.Date
	Assinatura    string
	Idtroca       pgtype.Int4
}

func (q *Queries) AddEntregaVinculada(ctx context.Context, arg AddEntregaVinculadaParams) (int32, error) {
	row := q.db.QueryRow(ctx, addEntregaVinculada,
		arg.Idfuncionario,
		arg.DataEntrega,
		arg.Assinatura,
		arg.Idtroca,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addTrocaEpi = `-- name: AddTrocaEpi :one
INSERT INTO devolucao (
    IdFuncionario, IdEpi, IdMotivo, data_devolucao, IdTamanho, 
    quantidadeAdevolver, IdEpiNovo, IdTamanhoNovo, quantidadeNova, assinatura_digital
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id
`

type AddTrocaEpiParams struct {
	Idfuncionario       int32
	Idepi               int32
	Idmotivo            int32
	DataDevolucao       pgtype.Date
	Idtamanho           int32
	Quantidadeadevolver int32
	Idepinovo           pgtype.Int4
	Idtamanhonovo       pgtype.Int4
	Quantidadenova      pgtype.Int4
	AssinaturaDigital   string
}

func (q *Queries) AddTrocaEpi(ctx context.Context, arg AddTrocaEpiParams) (int32, error) {
	row := q.db.QueryRow(ctx, addTrocaEpi,
		arg.Idfuncionario,
		arg.Idepi,
		arg.Idmotivo,
		arg.DataDevolucao,
		arg.Idtamanho,
		arg.Quantidadeadevolver,
		arg.Idepinovo,
		arg.Idtamanhonovo,
		arg.Quantidadenova,
		arg.AssinaturaDigital,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const cancelarDevolucao = `-- name: CancelarDevolucao :execrows
UPDATE devolucao
SET cancelada_em = NOW(),
    ativo = FALSE
WHERE id = $1 AND cancelada_em IS NULL
`

func (q *Queries) CancelarDevolucao(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, cancelarDevolucao, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listarDevolucoes = `-- name: ListarDevolucoes :many
SELECT 
    d.id, d.IdFuncionario, f.nome as func_nome, f.matricula,
    f.IdDepartamento, dd.nome as dep_nome,
    f.IdFuncao, ff.nome as funcao_nome,
    d.IdEpi, e.nome as epi_antigo_nome, e.fabricante as epi_antigo_fab, e.CA as epi_antigo_ca,
    d.IdTamanho as tam_antigo_id, t.tamanho as tam_antigo_nome,
    d.quantidadeAdevolver, d.IdMotivo, m.motivo as motivo_nome,
    d.IdEpiNovo, en.nome as epi_novo_nome, en.fabricante as epi_novo_fab, en.CA as epi_novo_ca,
    d.quantidadeNova, d.IdTamanhoNovo, tn.tamanho as tam_novo_nome,
    d.assinatura_digital, d.data_devolucao
FROM devolucao d
INNER JOIN epi e ON d.IdEpi = e.id
INNER JOIN funcionario f ON d.IdFuncionario = f.id	
INNER JOIN departamento dd ON f.IdDepartamento = dd.id
INNER JOIN funcao ff ON f.IdFuncao = ff.id
INNER JOIN tamanho t ON d.IdTamanho = t.id
INNER JOIN motivo_devolucao m ON d.IdMotivo = m.id
LEFT JOIN epi en ON d.IdEpiNovo = en.id
LEFT JOIN tamanho tn ON d.IdTamanhoNovo = tn.id
WHERE 
    (($1::boolean IS FALSE AND d.cancelada_em IS NULL) OR
     ($1::boolean IS TRUE AND d.cancelada_em IS NOT NULL))
AND ($2::int IS NULL OR d.id = $2)
AND ($3::text IS NULL OR f.matricula = $3)
ORDER BY d.data_devolucao DESC
`

type ListarDevolucoesParams struct {
	Canceladas bool
	ID         pgtype.Int4
	Matricula  pgtype.Text
}

type ListarDevolucoesRow struct {
	ID                  int32
	Idfuncionario       int32
	FuncNome            string
	Matricula           string
	Iddepartamento      int32
	DepNome             string
	Idfuncao            int32
	FuncaoNome          string
	Idepi               int32
	EpiAntigoNome       string
	EpiAntigoFab        string
	EpiAntigoCa         string
	TamAntigoID         int32
	TamAntigoNome       string
	Quantidadeadevolver int32
	Idmotivo            int32
	MotivoNome          string
	Idepinovo           pgtype.Int4
	EpiNovoNome         pgtype.Text
	EpiNovoFab          pgtype.Text
	EpiNovoCa           pgtype.Text
	Quantidadenova      pgtype.Int4
	Idtamanhonovo       pgtype.Int4
	TamNovoNome         pgtype.Text
	AssinaturaDigital   string
	DataDevolucao       pgtype.Date
}

func (q *Queries) ListarDevolucoes(ctx context.Context, arg ListarDevolucoesParams) ([]ListarDevolucoesRow, error) {
	rows, err := q.db.Query(ctx, listarDevolucoes, arg.Canceladas, arg.ID, arg.Matricula)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListarDevolucoesRow
	for rows.Next() {
		var i ListarDevolucoesRow
		if err := rows.Scan(
			&i.ID,
			&i.Idfuncionario,
			&i.FuncNome,
			&i.Matricula,
			&i.Iddepartamento,
			&i.DepNome,
			&i.Idfuncao,
			&i.FuncaoNome,
			&i.Idepi,
			&i.EpiAntigoNome,
			&i.EpiAntigoFab,
			&i.EpiAntigoCa,
			&i.TamAntigoID,
			&i.TamAntigoNome,
			&i.Quantidadeadevolver,
			&i.Idmotivo,
			&i.MotivoNome,
			&i.Idepinovo,
			&i.EpiNovoNome,
			&i.EpiNovoFab,
			&i.EpiNovoCa,
			&i.Quantidadenova,
			&i.Idtamanhonovo,
			&i.TamNovoNome,
			&i.AssinaturaDigital,
			&i.DataDevolucao,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
