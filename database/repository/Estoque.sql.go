// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: Estoque.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const abaterEstoqueLote = `-- name: AbaterEstoqueLote :execrows
UPDATE entrada_epi 
SET quantidadeAtual = quantidadeAtual - $1 
WHERE id = $2 
  AND ativo = TRUE
  AND quantidadeAtual >= $1
`

type AbaterEstoqueLoteParams struct {
	Quantidadeatual int32
	ID              int32
}

func (q *Queries) AbaterEstoqueLote(ctx context.Context, arg AbaterEstoqueLoteParams) (int64, error) {
	result, err := q.db.Exec(ctx, abaterEstoqueLote, arg.Quantidadeatual, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listarLotesParaConsumo = `-- name: ListarLotesParaConsumo :many
SELECT id, quantidadeAtual, data_validade, valor_unitario 
FROM entrada_epi 
WHERE IdEpi = $1 
  AND IdTamanho = $2 
  AND quantidadeAtual > 0 
  AND data_validade >= CURRENT_DATE
  AND ativo = TRUE
ORDER BY data_validade ASC
FOR UPDATE
`

type ListarLotesParaConsumoParams struct {
	Idepi     int32
	Idtamanho int32
}

type ListarLotesParaConsumoRow struct {
	ID              int32
	Quantidadeatual int32
	DataValidade    pgtype.Date
	ValorUnitario   pgtype.Numeric
}

// O PostgreSQL usa FOR UPDATE para o que o SQL Server chama de UPDLOCK.
func (q *Queries) ListarLotesParaConsumo(ctx context.Context, arg ListarLotesParaConsumoParams) ([]ListarLotesParaConsumoRow, error) {
	rows, err := q.db.Query(ctx, listarLotesParaConsumo, arg.Idepi, arg.Idtamanho)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListarLotesParaConsumoRow
	for rows.Next() {
		var i ListarLotesParaConsumoRow
		if err := rows.Scan(
			&i.ID,
			&i.Quantidadeatual,
			&i.DataValidade,
			&i.ValorUnitario,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registrarItemEntrega = `-- name: RegistrarItemEntrega :exec
INSERT INTO epis_entregues (IdEpi, IdTamanho, quantidade, IdEntrega, IdEntrada, valor_unitario) 
VALUES ($1, $2, $3, $4, $5, $6)
`

type RegistrarItemEntregaParams struct {
	Idepi         int32
	Idtamanho     int32
	Quantidade    int32
	Identrega     int32
	Identrada     int32
	ValorUnitario pgtype.Numeric
}

func (q *Queries) RegistrarItemEntrega(ctx context.Context, arg RegistrarItemEntregaParams) error {
	_, err := q.db.Exec(ctx, registrarItemEntrega,
		arg.Idepi,
		arg.Idtamanho,
		arg.Quantidade,
		arg.Identrega,
		arg.Identrada,
		arg.ValorUnitario,
	)
	return err
}

const reporEstoqueLote = `-- name: ReporEstoqueLote :execrows
UPDATE entrada_epi 
SET quantidadeAtual = quantidadeAtual + $1 
WHERE id = $2 
  AND ativo = TRUE
  AND quantidadeAtual >= $1
`

type ReporEstoqueLoteParams struct {
	Quantidadeatual int32
	ID              int32
}

func (q *Queries) ReporEstoqueLote(ctx context.Context, arg ReporEstoqueLoteParams) (int64, error) {
	result, err := q.db.Exec(ctx, reporEstoqueLote, arg.Quantidadeatual, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
