// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: Estoque.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const abaterEstoqueLote = `-- name: AbaterEstoqueLote :execrows
UPDATE entrada_epi 
SET quantidadeAtual = quantidadeAtual - $1 
WHERE id = $2 
  AND tenant_id = $3 -- SEGURANÇA: Garante que o lote pertence à empresa antes de subtrair
  AND ativo = TRUE
  AND quantidadeAtual >= $1
`

type AbaterEstoqueLoteParams struct {
	Quantidadeatual int32
	ID              int32
	TenantID        int32
}

func (q *Queries) AbaterEstoqueLote(ctx context.Context, arg AbaterEstoqueLoteParams) (int64, error) {
	result, err := q.db.Exec(ctx, abaterEstoqueLote, arg.Quantidadeatual, arg.ID, arg.TenantID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const devolverItemAoEstoque = `-- name: DevolverItemAoEstoque :exec
UPDATE entrada_epi
SET quantidadeAtual = entrada_epi.quantidadeAtual + $4 -- Quantidade é o $4 agora
WHERE id = (
    SELECT ee.id
    FROM entrada_epi ee
    WHERE ee.tenant_id = $1 -- SEGURANÇA NA SUBQUERY
      AND ee.IdEpi = $2 
      AND ee.IdTamanho = $3
      AND ee.ativo = TRUE -- Boa prática garantir que não devolve para lote inativo
    ORDER BY ee.data_entrada DESC
    LIMIT 1
)
AND tenant_id = $1
`

type DevolverItemAoEstoqueParams struct {
	TenantID        int32
	Idepi           int32
	Idtamanho       int32
	Quantidadeatual int32
}

func (q *Queries) DevolverItemAoEstoque(ctx context.Context, arg DevolverItemAoEstoqueParams) error {
	_, err := q.db.Exec(ctx, devolverItemAoEstoque,
		arg.TenantID,
		arg.Idepi,
		arg.Idtamanho,
		arg.Quantidadeatual,
	)
	return err
}

const listarLotesParaConsumo = `-- name: ListarLotesParaConsumo :many
SELECT id, quantidadeAtual, data_validade, valor_unitario 
FROM entrada_epi 
WHERE tenant_id = $1 -- SEGURANÇA: Só busca lotes da empresa logada
  AND IdEpi = $2 
  AND IdTamanho = $3 
  AND quantidadeAtual > 0 
  AND data_validade >= CURRENT_DATE
  AND ativo = TRUE
ORDER BY data_validade ASC
FOR UPDATE
`

type ListarLotesParaConsumoParams struct {
	TenantID  int32
	Idepi     int32
	Idtamanho int32
}

type ListarLotesParaConsumoRow struct {
	ID              int32
	Quantidadeatual int32
	DataValidade    pgtype.Date
	ValorUnitario   pgtype.Numeric
}

// O PostgreSQL usa FOR UPDATE para travar apenas as linhas desse cliente específico.
func (q *Queries) ListarLotesParaConsumo(ctx context.Context, arg ListarLotesParaConsumoParams) ([]ListarLotesParaConsumoRow, error) {
	rows, err := q.db.Query(ctx, listarLotesParaConsumo, arg.TenantID, arg.Idepi, arg.Idtamanho)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListarLotesParaConsumoRow
	for rows.Next() {
		var i ListarLotesParaConsumoRow
		if err := rows.Scan(
			&i.ID,
			&i.Quantidadeatual,
			&i.DataValidade,
			&i.ValorUnitario,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registrarItemEntrega = `-- name: RegistrarItemEntrega :exec
INSERT INTO epis_entregues (
    tenant_id, -- Novo campo
    IdEpi, IdTamanho, quantidade, IdEntrega, IdEntrada
) 
VALUES ($1, $2, $3, $4, $5, $6)
`

type RegistrarItemEntregaParams struct {
	TenantID   int32
	Idepi      int32
	Idtamanho  int32
	Quantidade int32
	Identrega  int32
	Identrada  int32
}

func (q *Queries) RegistrarItemEntrega(ctx context.Context, arg RegistrarItemEntregaParams) error {
	_, err := q.db.Exec(ctx, registrarItemEntrega,
		arg.TenantID,
		arg.Idepi,
		arg.Idtamanho,
		arg.Quantidade,
		arg.Identrega,
		arg.Identrada,
	)
	return err
}

const reporEstoqueLote = `-- name: ReporEstoqueLote :execrows
UPDATE entrada_epi 
SET quantidadeAtual = quantidadeAtual + $1 
WHERE id = $2 
  AND tenant_id = $3 -- SEGURANÇA
  AND ativo = TRUE
`

type ReporEstoqueLoteParams struct {
	Quantidadeatual int32
	ID              int32
	TenantID        int32
}

func (q *Queries) ReporEstoqueLote(ctx context.Context, arg ReporEstoqueLoteParams) (int64, error) {
	result, err := q.db.Exec(ctx, reporEstoqueLote, arg.Quantidadeatual, arg.ID, arg.TenantID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
